<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,intial-scale=1.0">
    <meta http-http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Internet Archeologist</title>
    <link rel="stylesheet" href="css\main.css">
</head>
<body>

  <p id="screen-log"></p>
  <p id="touch-log"></p>
  <p id="drag-start"></p>
  <script src=js/three.js></script>
  <script src=js/DragControls.js></script>
  <script src=js/Tween.js></script>
  <script src=js/MTLLoader.js></script>
  <script src=js/PointerLockControls.js></script>
  <script src=js/mobile-detect.js></script>
  <script src=js/GLTFLoader.js></script>
  <script src=js/OBJLoader.js></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.3/TweenMax.min.js"></script>

  <script>

    var pressed = 0;
    var xcord = 0;
    var ycord = 0;
    var touchxcord = 0;
    var touchycord = 0;
    var mouse = new THREE.Vector2(), INTERSECTED;

    var _plane = new THREE.Plane();
    var raycaster = new THREE.Raycaster();
    var _intersection = new THREE.Vector3();
    var link = null;

    var scene = new THREE.Scene();
    var _mouse = new THREE.Vector2();
    var src = document.getElementById("source");
    var detector = new MobileDetect(window.navigator.useragent);
    var itstheobject;
    console.log( "Mobile: " + detector.mobile());
  //  console.log( touchObject());



    var camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 10000)
    camera.position.set(0,0,300);
    scene.add(camera);

    var renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setClearColor("#e5e5e5");
    renderer.setSize(window.innerWidth,window.innerHeight);

    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth,window.innerHeight)
        camera.aspect = window.innerWidth / window.innerHeight;

        camera.updateProjectionMatrix();
    })
  //  var MTLLoader = new THREE.MTLLoader();
  //  var objloader = new THREE.OBJloader();
  //  OBJLoader.load("assets/folder v1.obj", function(mesh){
  //    scene.add(mesh);
  //  });

  /*  var loader = new THREE.GLTFLoader();
    loader.load('assets/folder.glb', handle_load);
    var folder;

    function handle_load(gltf) {
      folder = gltf.scene.children[0];
      folder.material = new THREE.MeshLambertMaterial({color: 0xffff00});
      scene.add( folder );
      folder.position.x = (window.innerWidth * .02);
      folder.position.y = 0;
      folder.position.z = 0;
    } */
      let drags = document.querySelector('#drag-start');
    var mobile = true;
    var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
		var element = document.getElementById('text');
		if (isMobile) {
  			mobile = true;
		} else {
			mobile = false;
    //  drags.innerText = `
      //  started`

		}
    if(detector.mobile() == null){
      mobile = false;
    }else {
    //  drags.innerText = `
    //    started`;
    }

    var geometry = new THREE.BoxGeometry( 20, 20, 20 );


    var objects = [];

    var light = new THREE.PointLight(0xFFFFFF, 5, 3000)
    light.position.set(0,0,300)
    scene.add(light);

    for( var i = 0; i < 30; i++){
      var wallgeometry = new THREE.BoxGeometry( (Math.random()* 2 +1) * 20, (Math.random()* 2 +1) * 20,10 );
      var wall = new THREE.Mesh( wallgeometry, new THREE.MeshLambertMaterial( {color: 0xCCCCCC} ));
       wall.position.x = (Math.random() * 180) - 90;
       wall.position.y = (Math.random() * 180) - 90;
       wall.position.z = (Math.random() * 90);

       wall.userData = {
  				URL: null
  			};

       scene.add ( wall );

       objects.push( wall);
    }


    var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( {color: 0xffff00} ));
     object.position.x = (Math.random() * 180) - 90;
     object.position.y = (Math.random() * 180) - 90;
     object.position.z = (Math.random() * 40) - 20;

     object.userData = {
				URL: 'https://www.youtube.com/watch?v=5JHrn5CgGno'
			};

     scene.add ( object );

     objects.push( object);





     var object2 = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( {color: 0xFF00F7} ));
      object2.position.x = (Math.random() * 180) - 90;
      object2.position.y = (Math.random() * 180) - 90;
      object2.position.z = (Math.random() * 40) - 20;

      object2.userData = {
 				URL: 'https://www.reddit.com/r/place/top/?t=all'
 			};


      scene.add ( object2 );

      objects.push( object2);
  //   objects.push( folder);

  var object3 = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( {color: 0x00FF09} ));
   object3.position.x = (Math.random() * 180) - 90;
   object3.position.y = (Math.random() * 180) - 90;
   object3.position.z = (Math.random() * 40) - 20;

   object3.userData = {
     URL: 'https://www.youtube.com/watch?v=LOKY7ER6Nsg&list=LLkOjIiUe_rBgcc90gJwhmzg&index=119&t=0s'
   };



   scene.add ( object3 );

   objects.push( object3);



    var object5 = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( {color: 0xFF0000} ));
     object5.position.x = (Math.random() * 180) - 90;
     object5.position.y = (Math.random() * 180) - 90;
     object5.position.z = (Math.random() * 40) - 20;

     object5.userData = {
       URL: 'https://archive.org/web/'
     };

     scene.add ( object5 );

     objects.push( object5);

     var object6 = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( {color: 0x33FFFA} ));
      object6.position.x = (Math.random() * 180) - 90;
      object6.position.y = (Math.random() * 180) - 90;
      object6.position.z = (Math.random() * 40) - 20;

      object6.userData = {
        URL: 'https://vignette.wikia.nocookie.net/vsbattles/images/b/be/Roxas_%28Art%29_KHD.png/revision/latest?cb=20160217034307'
      };

      scene.add ( object6 );

      objects.push( object6);

       var object7 = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial());
        object7.position.x = (Math.random() * 180) - 90;
        object7.position.y = (Math.random() * 180) - 90;
        object7.position.z = (Math.random() * 40) - 20;

        object7.userData = {
          URL: 'https://docs.google.com/forms/d/e/1FAIpQLSdVTvUTXgLf_6Kz50Ubdu6T4oriGgyjGUsO1bnCAIShN9vbPw/viewform?usp=sf_link'
        };

        scene.add ( object7 );

        objects.push( object7);



    var render = function() {
           requestAnimationFrame(render);
           //object.rotation.x += 0.05;
           object7.rotation.x += .03;
         object7.rotation.y -= .03;
         object7.rotation.z -= .03;
           renderer.render(scene, camera);

      }

      const forward = () => {
        if (f.position.z() < 5){
          requestAnimationFrame(forward)
        }

        sphere.position.z += 0.2

        render.render(scene, camera)
      }

      //  renderer.domElement.addEventListener( 'click', raycast, false )
/*      renderer.domElement.addEventListener( 'touchstart', raycast, true );

      function raycast ( e ){
        mouse.x =  (touchxcord / window.innerWidth ) * 2 - 1;
        mouse.y = -( touchycord / window.innerHeight ) * 2 + 1;

    //2. set the picking ray from the camera position and mouse coordinates
    raycaster.setFromCamera( mouse, camera );

    //3. compute intersections (note the 2nd parameter)
    var intersects = raycaster.intersectObjects( scene.children );
    console.log( intersects.length);
    for ( var i = 0; i < intersects.length; i++ ) {
        console.log(69);
        /*
            An intersection has the following properties :
                - object : intersected object (THREE.Mesh)
                - distance : distance from camera to intersection (number)
                - face : intersected face (THREE.Face3)
                - faceIndex : intersected face index (number)
                - point : intersection point (THREE.Vector3)
                - uv : intersection point in the object's UV coordinates (THREE.Vector2)

    }
// Step 2: Detect normal objects
    //1. sets the mouse position with a coordinate system where the center
    //   of the screen is the origin
    mouse.x = ( touchxcord / window.innerWidth ) * 2 - 1;
    mouse.y = - ( touchycord / window.innerHeight ) * 2 + 1;
    console.log( mouse.x);
    console.log( mouse.y);

    //2. set the picking ray from the camera position and mouse coordinates
    raycaster.setFromCamera(mouse, camera );

    //3. compute intersections (no 2nd parameter true anymore)
    var intersects = raycaster.intersectObjects( objects );
    console.log( intersects.length);
    if ( intersects.length > 0 ) {
        console.log( intersects[ i ] );
        /*
            An intersection has the following properties :
                - object : intersected object (THREE.Mesh)
                - distance : distance from camera to intersection (number)
                - face : intersected face (THREE.Face3)
                - faceIndex : intersected face index (number)
                - point : intersection point (THREE.Vector3)
                - uv : intersection point in the object's UV coordinates (THREE.Vector2)

    }

}
*/






      let screenLog = document.querySelector('#screen-log');
      let touchLog = document.querySelector('#touch-log');

      document.addEventListener('mousemove', logKey);

    function logKey(e) {

      xcord = e.clientX;
      ycord = e.clientY;
  //    screenLog.innerText = `
    //    Screen X/Y: ${e.screenX}, ${e.screenY}
      //  Touch X/Y: ${e.clientX}, ${e.clientY}`;
    }
    document.addEventListener('touchstart', tlogKey);
      function tlogKey(e) {



          touchxcord = parseInt(e.touches[0].clientX);
          touchycord = parseInt(e.touches[0].clientY);
          mouse.x = ( touchxcord / window.innerWidth ) * 2 - 1;
          mouse.y = - ( touchycord / window.innerHeight ) * 2 + 1;



    //  touchLog.innerText = `
    //    Touch X/Y: ${parseInt(e.touches[0].clientX)}, ${parseInt(e.touches[0].clientY)}`;
    }
      var controls = new THREE.DragControls( objects, camera, renderer.domElement );



      controls.addEventListener( 'dragstart', function ( event ) {
        //  document.getElementById("demo").innerHTML = xcord;

          event.object.position.z = event.object.position.z + 5;


          //document.getElementById("demo").innerHTML = xcord;
          if(touchycord != 0)
          {

            _mouse.x = touchxcord;
            _mouse.y = touchycord;
            mouse.x = ( touchxcord / window.innerWidth ) * 2 - 1;
            mouse.y = - ( touchycord / window.innerHeight ) * 2 + 1;
            console.log( mouse.x);
            console.log( mouse.y);
            pressed = 1;

          }
          else {
            _mouse.x = xcord;
            _mouse.y = ycord;
            mouse.x = ( xcord / window.innerWidth ) * 2 - 1;
            mouse.y = - ( ycord / window.innerHeight ) * 2 + 1;
            console.log( mouse.x);
            console.log( mouse.y);
          }


        } );

      controls.addEventListener( 'drag', function ( event ) {
        //  document.getElementById("demo").innerHTML = xcord;
          event.object.position.z = event.object.position.z + 5;
      //    drags.innerText = `
      //      started ${touchxcord}, ${touchycord}`
      //    document.getElementById("demo").innerHTML = xcord;





      } );

      controls.addEventListener( 'dragend', function ( event ) {
          //document.getElementById("demo").innerHTML = xcord;
    //      pressed = 0;
    raycaster.setFromCamera( mouse, camera );

    var intersects = raycaster.intersectObjects( scene.children );
      console.log(intersects.length);
    if ( intersects.length > 0 ) {
        console.log(intersects.length);
      if ( INTERSECTED != intersects[ 0 ].object ) {

        if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
        link = intersects[0].object.userData.URL;
        if(link != null)
        {
          window.open(link);
        }

        console.log(link);
        console.log(intersects[0].object.userData.URL);

      }

    } else {

      if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

      INTERSECTED = null;

    }
           event.object.position.z = event.object.position.z - 5;
           /*if (_mouse.x < xcord+100 && _mouse.x > xcord-100 && _mouse.y < ycord + 100 && _mouse.y > ycord - 100){
             window.open("https://www.w3schools.com");
           } */
          // drags.innerText = `
            // ended ${touchxcord}, ${touchycord}`

          /*if(touchycord =! 0) {
             if (mouse.x < touchxcord + 3 && _mouse.x > touchxcord - 3 && _mouse.y < touchycord + 3 && _mouse.y > touchycord - 3){
              // console.log( controls.touchObject().position.x);
               //if(touchObject().position.x == object.position.x)
               //{
                  window.open(link);
               //}

              // drags.innerText = `
                // ended ${touchxcord}, ${touchycord}`
             }
           } else {
             if (_mouse.x == xcord && _mouse.y == ycord){
               window.open("[intersects[0].object.userData.URL]");
             }
           }
           pressed = 0;
*/
        //   pressed = 0;


      } );

    render();





  //  this.tl = new TimelineMax() .delay(.3);
  //  this.tl.to(this.object.position, .5, {x: (0), ease: Expo.easeOut})




  </script>

</body>
</html>
